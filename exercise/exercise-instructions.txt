Exercise 1: Creating a Functional Component

Description: 

Create a simple functional component named `Greeting` that accepts a name prop and displays "Hello, {name}!".



Exercise 2: Component Hierarchy
Description: Build a component hierarchy with a parent component Dashboard that renders child components UserProfile and UserStats.




Exercise 3: Passing Data with Props
Description: Modify UserProfile to accept a user prop and display the user's name and age.




Exercise 4: Using useState Hook
Description: Create a Counter component that displays a count and has buttons to increment and decrement the count.



Exercise 5: Handling State Changes
Description: Explain how state changes in the Counter component cause re-rendering.


Exercise 6: Avoiding Prop Drilling with Context
Description: Create a ThemeContext to manage a theme state and use it in a deeply nested component without passing props through intermediate components.



Exercise 7: Understanding React Context
Description: Discuss the benefits and drawbacks of using React Context.
Answer:

Benefits:

Avoids Prop Drilling: Allows passing data through the component tree without having to pass props down manually at every level.
Global State Management: Useful for global settings like themes, locales, or authenticated user data.
Drawbacks:

Performance Issues: Every context consumer will re-render when the context value changes, which can lead to performance problems if not managed correctly.
Complexity: Can make components less reusable and more tightly coupled to the context.


Exercise 8: Using useEffect Hook
Description: Create a Timer component that uses useEffect to update the time every second.


Exercise 9: Managing Component Lifecycle
Description: Explain how useEffect manages the lifecycle of functional components.
Answer:

The useEffect hook allows you to perform side effects in functional components. It combines the functionality of componentDidMount, componentDidUpdate, and componentWillUnmount 
in class components. The effect runs after the render and can optionally clean up before the component unmounts or before re-running the effect.



Exercise 10: Creating a Higher-Order Component (HOC)
Description: Implement an HOC named withLoading that shows a loading indicator while data is being fetched.




Exercise 11: Benefits and Limitations of HOCs
Description: Discuss the use cases and limitations of Higher-Order Components.
Answer:

Use Cases:

Code Reusability: Share common functionality between components.
Cross-Cutting Concerns: Handle logging, authentication, or data fetching in a centralized way.
Limitations:

Wrapper Hell: Can lead to deeply nested component hierarchies.
Props Collision: Need to carefully manage props to avoid conflicts.
Less Intuitive: May be harder to understand compared to hooks.


Exercise 12: Implementing Error Boundaries
Description: Create an error boundary component to catch errors in the component tree.



Exercise 13: Debugging with React DevTools
Description: Explain how to use React DevTools to inspect components and their state.
Answer:

React DevTools is a browser extension that allows developers to inspect the React component tree. You can:

Inspect Component Hierarchy: View the tree of components rendered by React.
Examine Props and State: See the current props and state of any component.
Performance Profiling: Measure the performance of your components.



Exercise 14: Diagnosing Performance Issues
Description: Use the React Profiler to identify and optimize slow components.
Answer:

The React Profiler helps identify performance bottlenecks in applications. You can record a profiling session and see:

Which Components Rendered: Identify components that re-render frequently.
Render Times: See how long each component took to render.
Flame Chart: Visual representation of rendering hierarchy.


Exercise 15: Integrating Next.js
Description: Briefly explain how to integrate Next.js for server-side rendering.
Answer:

Next.js is a React framework that enables server-side rendering and static site generation. It handles routing and offers features like:

Automatic Code Splitting: Optimizes performance by splitting code into smaller chunks.
Server-Side Rendering: Renders pages on the server for improved SEO and performance.
Static Site Generation: Pre-renders pages at build time.
Integration involves setting up pages in the pages directory and using Next.js-specific features like getServerSideProps.


Exercise 16: Code Splitting with React.lazy
Description: Implement lazy loading of components to improve performance.


Exercise 17: Memoization with React.memo
Description: Use React.memo to prevent unnecessary re-renders of pure components.



Exercise 18: Optimizing Expensive Calculations with useMemo
Description: Use useMemo to memoize an expensive function.







Exercise 19: Using useCallback for Function Memoization
Description: Prevent unnecessary re-renders by memoizing event handlers with useCallback.


Exercise 20: Custom Hooks
Description: Create a custom hook useWindowWidth that returns the current window width.


Exercise 21: Error Handling in Event Handlers
Description: Show how errors in event handlers do not propagate to error boundaries and how to handle them.


